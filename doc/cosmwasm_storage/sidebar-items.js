window.SIDEBAR_ITEMS = {"fn":[["bucket","An alias of Bucket::new for less verbose usage"],["bucket_read","An alias of ReadonlyBucket::new for less verbose usage"],["currval","currval returns the last value returned by nextval. If the sequence has never been used, then it will return 0."],["nextval","nextval increments the counter by 1 and returns the new value. On the first time it is called (no sequence info in db) it will return 1."],["prefixed","An alias of PrefixedStorage::new for less verbose usage"],["prefixed_read","An alias of ReadonlyPrefixedStorage::new for less verbose usage"],["sequence","Sequence creates a custom Singleton to hold an empty sequence"],["singleton","An alias of Singleton::new for less verbose usage"],["singleton_read","An alias of ReadonlySingleton::new for less verbose usage"],["to_length_prefixed","Calculates the raw key prefix for a given namespace as documented in https://github.com/webmaster128/key-namespacing#length-prefixed-keys"],["to_length_prefixed_nested","Calculates the raw key prefix for a given nested namespace as documented in https://github.com/webmaster128/key-namespacing#nesting"]],"struct":[["Bucket",""],["PrefixedStorage",""],["ReadonlyBucket",""],["ReadonlyPrefixedStorage",""],["ReadonlySingleton","ReadonlySingleton only requires a Storage and exposes only the methods of Singleton that donâ€™t modify state."],["Singleton","Singleton effectively combines PrefixedStorage with TypedStorage to work on a single storage key. It performs the to_length_prefixed transformation on the given name to ensure no collisions, and then provides the standard TypedStorage accessors, without requiring a key (which is defined in the constructor)"]]};