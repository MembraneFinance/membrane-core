window.SIDEBAR_ITEMS = {"enum":[["Bound","`Bound` is used to define the two ends of a range. `None` means that we don’t limit that side of the range at all. `Inclusive` means we use the given value as a limit and include anything at that exact key. `Exclusive` means we use the given value as a limit and exclude anything at that exact key."],["Key",""],["PrefixBound",""],["RawBound","`RawBound` is used to define the two ends of a range, more explicit than `Option<u8>`. `None` means that we don’t limit that side of the range at all. `Inclusive` means we use the given bytes as a limit and include anything at that exact key. `Exclusive` means we use the given bytes as a limit and exclude anything at that exact key. See `Bound` for a type safe way to build these bounds."],["Strategy",""]],"fn":[["index_string",""],["index_string_tuple",""],["index_triple",""],["index_tuple",""],["range_with_prefix",""]],"struct":[["IndexedMap","`IndexedMap` works like a `Map` but has a secondary index"],["IndexedSnapshotMap","`IndexedSnapshotMap` works like a `SnapshotMap` but has a secondary index"],["IntKeyOld",""],["Item","Item stores one typed item at the given key. This is an analog of Singleton. It functions the same way as Path does but doesn’t use a Vec and thus has a const fn constructor."],["Map",""],["MultiIndex","MultiIndex stores (namespace, index_name, idx_value, pk) -> b“pk_len“. Allows many values per index, and references pk. The associated primary key value is stored in the main (pk_namespace) map, which stores (namespace, pk_namespace, pk) -> value."],["Path",""],["Prefix",""],["SnapshotItem","Item that maintains a snapshot of one or more checkpoints. We can query historical data as well as current state. What data is snapshotted depends on the Strategy."],["SnapshotMap","Map that maintains a snapshots of one or more checkpoints. We can query historical data as well as current state. What data is snapshotted depends on the Strategy."],["UniqueIndex","UniqueIndex stores (namespace, index_name, idx_value) -> {key, value} Allows one value per index (i.e. unique) and copies pk and data The optional PK type defines the type of Primary Key deserialization."]],"trait":[["Bounder",""],["CwIntKey","Our int keys are simply the big-endian representation bytes for unsigned ints, but “sign-flipped” (xored msb) big-endian bytes for signed ints."],["Endian",""],["Index",""],["IndexList",""],["KeyDeserialize",""],["Prefixer",""],["PrimaryKey","`PrimaryKey` needs to be implemented for types that want to be a `Map` (or `Map`-like) key, or part of a key."]]};